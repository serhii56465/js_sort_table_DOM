{"version":3,"sources":["scripts/main.js"],"names":["sortTable","e","thTarget","target","matches","trList","table","rows","switching","i","x","y","shouldSwitch","dir","index","closest","querySelectorAll","map","item","innerText","indexOf","switchcount","document","querySelector","length","getElementsByTagName","xf","parseFloat","innerHTML","slice","replace","yf","toLowerCase","parentNode","insertBefore","body","addEventListener"],"mappings":";AAAA,aAoFA,SAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,wIAAA,SAAA,EAAA,EAAA,GAAA,GAAA,EAAA,CAAA,GAAA,iBAAA,EAAA,OAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,UAAA,SAAA,KAAA,GAAA,MAAA,GAAA,GAAA,MAAA,WAAA,GAAA,EAAA,cAAA,EAAA,EAAA,YAAA,MAAA,QAAA,GAAA,QAAA,EAAA,MAAA,KAAA,GAAA,cAAA,GAAA,2CAAA,KAAA,GAAA,EAAA,EAAA,QAAA,GAAA,SAAA,EAAA,GAAA,GAAA,oBAAA,QAAA,OAAA,YAAA,OAAA,GAAA,OAAA,MAAA,KAAA,GAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,OAAA,EAAA,GAAA,SAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,UAAA,EAAA,EAAA,QAAA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAlFA,IAAMA,EAAY,SAACC,GACTC,IAAAA,EAAWD,EAAEE,OACf,GAACD,EAASE,QAAQ,MAAlB,CAGEC,IAIFC,EAAOC,EAAMC,EAAWC,EAAGC,EAAGC,EAAGC,EAAcC,EAD7CC,EADS,EAFAZ,EAASa,QAAQ,MACXC,iBAAiB,OACZC,IAAI,SAAAC,GAAQA,OAAAA,EAAKC,YACtBC,QAAQlB,EAASiB,WACkBE,EAAc,EAO/Db,IANPF,EAAQgB,SAASC,cAAc,SAC/Bf,GAAY,EAEZK,EAAM,MAGCL,GAAW,CAMXC,IAJLD,GAAY,EACZD,EAAOD,EAAMC,KAGRE,EAAI,EAAGA,EAAKF,EAAKiB,OAAS,EAAIf,IAS7BK,GAPJF,GAAe,EAGfF,EAAIH,EAAKE,GAAGgB,qBAAqB,MAAMX,GACvCH,EAAIJ,EAAKE,EAAI,GAAGgB,qBAAqB,MAAMX,GAG7B,IAAVA,EAAa,CACPY,IAAAA,EAAKC,WAAWjB,EAAEkB,UAAUC,MAAM,GAAGC,QAAQ,IAAK,MAClDC,EAAKJ,WAAWhB,EAAEiB,UAAUC,MAAM,GAAGC,QAAQ,IAAK,MAEpDjB,GAAO,OAAPA,GACIa,GAAAA,EAAKK,EAAI,CAEXnB,GAAe,EACf,YAEG,GAAW,QAAPC,GACLa,EAAKK,EAAI,CAEXnB,GAAe,EACf,YAIFC,GAAO,OAAPA,GACIH,GAAAA,EAAEkB,UAAUI,cAAgBrB,EAAEiB,UAAUI,cAAe,CAEzDpB,GAAe,EACf,YAEG,GAAW,QAAPC,GACLH,EAAEkB,UAAUI,cAAgBrB,EAAEiB,UAAUI,cAAe,CAEzDpB,GAAe,EACf,MAKRA,GAGFL,EAAKE,GAAGwB,WAAWC,aAAa3B,EAAKE,EAAI,GAAIF,EAAKE,IAClDD,GAAY,EAEZa,KAImB,GAAfA,GAA2B,OAAPR,IACtBA,EAAM,OACNL,GAAY,MAMtBc,SAASa,KAAKC,iBAAiB,QAASpC","file":"main.bbca971b.js","sourceRoot":"..\\src","sourcesContent":["'use strict';\n\nconst sortTable = (e) => {\n    const thTarget = e.target;\n    if (!thTarget.matches('th')) {\n        return;\n    }\n    const trList = thTarget.closest('tr');\n    const items = trList.querySelectorAll('th');\n    const thList = [...items].map(item => item.innerText);\n    const index = thList.indexOf(thTarget.innerText);\n    let table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;\n    table = document.querySelector(\"table\");\n    switching = true;\n    // Set the sorting direction to ascending:\n    dir = \"asc\";\n    /* Make a loop that will continue until\n    no switching has been done: */\n    while (switching) {\n      // Start by saying: no switching is done:\n      switching = false;\n      rows = table.rows;\n      /* Loop through all table rows (except the\n      first, which contains table headers): */\n      for (i = 1; i < (rows.length - 2); i++) {\n        // Start by saying there should be no switching:\n        shouldSwitch = false;\n        /* Get the two elements you want to compare,\n        one from current row and one from the next: */\n        x = rows[i].getElementsByTagName(\"TD\")[index];\n        y = rows[i + 1].getElementsByTagName(\"TD\")[index];\n        /* Check if the two rows should switch place,\n        based on the direction, asc or desc: */\n        if (index === 3) {\n            const xf = parseFloat(x.innerHTML.slice(1).replace(\",\", \".\"));\n            const yf = parseFloat(y.innerHTML.slice(1).replace(\",\", \".\"));\n\n            if (dir == \"asc\") {\n                if (xf > yf) {\n                  // If so, mark as a switch and break the loop:\n                  shouldSwitch = true;\n                  break;\n                }\n              } else if (dir == \"desc\") {\n                if (xf < yf) {\n                  // If so, mark as a switch and break the loop:\n                  shouldSwitch = true;\n                  break;\n                }\n              }\n        } else {\n            if (dir == \"asc\") {\n                if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {\n                  // If so, mark as a switch and break the loop:\n                  shouldSwitch = true;\n                  break;\n                }\n              } else if (dir == \"desc\") {\n                if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {\n                  // If so, mark as a switch and break the loop:\n                  shouldSwitch = true;\n                  break;\n                }\n              }\n        }\n      }\n      if (shouldSwitch) {\n        /* If a switch has been marked, make the switch\n        and mark that a switch has been done: */\n        rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);\n        switching = true;\n        // Each time a switch is done, increase this count by 1:\n        switchcount ++;\n      } else {\n        /* If no switching has been done AND the direction is \"asc\",\n        set the direction to \"desc\" and run the while loop again. */\n        if (switchcount == 0 && dir == \"asc\") {\n          dir = \"desc\";\n          switching = true;\n        }\n      }\n    }\n  }\n\ndocument.body.addEventListener('click', sortTable)\n"]}